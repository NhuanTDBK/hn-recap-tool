#!/usr/bin/env python
"""Simple script to deliver existing summaries to users via Telegram.

This script delivers summaries that have already been generated by
the personalized summarization pipeline.

Usage:
    python scripts/deliver_summaries.py
    python scripts/deliver_summaries.py --dry-run
    python scripts/deliver_summaries.py --user-id 3
"""

import asyncio
import argparse
import logging
import sys
from pathlib import Path
from datetime import datetime, timezone

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Load environment variables
from dotenv import load_dotenv

load_dotenv()

from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from app.infrastructure.database.models import User, Post, Summary
from app.infrastructure.config.settings import settings
from app.infrastructure.repositories.postgres.delivery_repo import (
    PostgresDeliveryRepository,
)
from app.presentation.bot.bot import BotManager, set_bot_manager
from app.presentation.bot.handlers.delivery import DigestDeliveryHandler

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


async def deliver_summaries(
    user_id: int = None, dry_run: bool = False, max_posts: int = 100
):
    """Deliver existing summaries to users.

    Args:
        user_id: Specific user ID to deliver to (None = all active users)
        dry_run: If True, don't actually send messages
        max_posts: Maximum posts to deliver per user
    """
    logger.info("=" * 80)
    logger.info("DELIVER EXISTING SUMMARIES")
    logger.info("=" * 80)
    logger.info(f"User ID: {user_id or 'all active users'}")
    logger.info(f"Dry run: {dry_run}")
    logger.info(f"Max posts: {max_posts}")
    logger.info("=" * 80 + "\n")

    # Create async engine
    engine = create_async_engine(
        settings.database_url,
        echo=False,
        pool_pre_ping=True,
    )

    async_session_factory = sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async with async_session_factory() as session:
        try:
            # Initialize bot
            bot_manager = BotManager()
            if not dry_run:
                await bot_manager.initialize()
                set_bot_manager(bot_manager)  # Set as global instance
                logger.info("✓ Bot initialized")

            # Get delivery components
            delivery_repo = PostgresDeliveryRepository(session)
            delivery_handler = DigestDeliveryHandler(delivery_repo)

            # Get active users
            stmt = select(User).where(User.status == "active")
            if user_id:
                stmt = stmt.where(User.id == user_id)

            result = await session.execute(stmt)
            users = list(result.scalars().all())

            logger.info(f"Found {len(users)} active user(s)\n")

            stats = {
                "total_users": len(users),
                "users_delivered": 0,
                "users_skipped": 0,
                "total_messages": 0,
            }

            batch_id = f"{datetime.now(timezone.utc).strftime('%Y-%m-%d')}-manual"

            for user in users:
                logger.info(
                    f"Processing user {user.id} (telegram_id={user.telegram_id})..."
                )

                # Get already delivered post IDs for this user
                from app.infrastructure.database.models import Delivery

                stmt_delivered = select(Delivery.post_id).where(
                    Delivery.user_id == user.id
                )
                result_delivered = await session.execute(stmt_delivered)
                delivered_post_ids = {row[0] for row in result_delivered.fetchall()}

                logger.info(f"  Already delivered: {len(delivered_post_ids)} posts")

                # Find posts with summaries for this user (exclude already delivered)
                stmt = (
                    select(Post)
                    .join(Summary, Summary.post_id == Post.id)
                    .where(
                        and_(
                            Summary.user_id == user.id,
                            Post.type == "story",
                            Post.is_dead == False,
                            Post.is_deleted == False,
                            (
                                ~Post.id.in_(delivered_post_ids)
                                if delivered_post_ids
                                else True
                            ),
                        )
                    )
                    .order_by(Post.score.desc())
                    .limit(max_posts)
                )

                result = await session.execute(stmt)
                posts = list(result.scalars().all())

                # Load summaries into posts
                for post in posts:
                    stmt = select(Summary).where(
                        and_(Summary.user_id == user.id, Summary.post_id == post.id)
                    )
                    result = await session.execute(stmt)
                    summary = result.scalar_one_or_none()
                    if summary:
                        post.summary = summary.summary_text

                logger.info(f"  Found {len(posts)} posts with summaries")

                if not posts:
                    logger.info(f"  Skipping user {user.id} - no posts")
                    stats["users_skipped"] += 1
                    continue

                if dry_run:
                    logger.info(f"  DRY RUN: Would send {len(posts)} posts")
                    stats["users_delivered"] += 1
                    stats["total_messages"] += len(posts)
                else:
                    # Deliver posts
                    delivery_result = await delivery_handler.send_digest_to_user(
                        user, posts, batch_id
                    )

                    logger.info(
                        f"  Delivered {delivery_result['messages_sent']} messages "
                        f"({len(delivery_result['failures'])} failures)"
                    )

                    stats["users_delivered"] += 1
                    stats["total_messages"] += delivery_result["messages_sent"]

                    # Update last_delivered_at
                    user.last_delivered_at = datetime.now(timezone.utc)
                    session.add(user)
                    await session.commit()

            # Print summary
            print("\n" + "=" * 80)
            print("DELIVERY COMPLETE")
            print("=" * 80)
            print(f"Total users: {stats['total_users']}")
            print(f"Users delivered: {stats['users_delivered']}")
            print(f"Users skipped: {stats['users_skipped']}")
            print(f"Total messages: {stats['total_messages']}")
            print("=" * 80 + "\n")

            if not dry_run and bot_manager._bot:
                await bot_manager.shutdown()

        finally:
            await engine.dispose()


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Deliver existing summaries to users")
    parser.add_argument(
        "--user-id", type=int, default=None, help="Specific user ID to deliver to"
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Dry run (don't send messages)"
    )
    parser.add_argument(
        "--max-posts", type=int, default=100, help="Maximum posts per user (default: 100)"
    )

    args = parser.parse_args()

    try:
        asyncio.run(
            deliver_summaries(
                user_id=args.user_id, dry_run=args.dry_run, max_posts=args.max_posts
            )
        )
        print("✓ Delivery completed successfully")
        sys.exit(0)

    except KeyboardInterrupt:
        print("\n⚠ Interrupted by user")
        sys.exit(1)

    except Exception as e:
        print(f"✗ Delivery failed: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
